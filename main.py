# [!] Do NOT edit this file unless you know what you are doing (Its not exactly stable).
# [!] If you need to change the basic settings of the bot, please see the .env-example

from dotenv import dotenv_values
from datetime import datetime
import re as regex
import threading
import requests
import random
import time
import os
#For an explenation of the 3 config options below, please see the .env-example file
SUBMITEDITS = dotenv_values()["SUBMITEDITS"].lower() == "true"
EnabledTasks = dotenv_values()["TASKS"].lower().replace("; ",";").split(";")
maxEditsPerMinute = int(dotenv_values()["EDITSPERMIN"])

def currentDate():
    #The current date in YYYY-MM-DD hh:mm:ss
    return str(datetime.fromtimestamp(time.time()//1))
def safeWriteToFile(filename,content,mode="w",encoding="UTF-8"):
    #Writes contents to a file, auto-creating the directory should it be missing
    if filename.find("\\") > -1:
        try:
            os.makedirs("/".join(filename.replace("\\","/").split("/")[:-1]),exist_ok=True)
        except:
            return False,f"Couldnt make directory for {filename}"
    try:
        file = open(filename,mode,encoding=encoding,newline="")
    except:
        return False,f"Failed to open {filename}"
    try:
        file.write(content)
    except Exception as exc:
        file.close()
        return False,f"Failed to write content for {filename}"
    file.close()
    return True,f"Successfully wrote to {filename}"
def log(content):
    #Manages the writing to a daily log file for debugging
    print(f"[Log {currentDate()[11:]}]",content)
    success,result = safeWriteToFile(f"Logs/{currentDate()[:10]}.log",f"[{currentDate()[11:]}] {content}\n","a")
    if not success:
        print(f"[Log {currentDate()[11:]}] Failed to write to log file: {result}")
    return success
if SUBMITEDITS:
    log("SUBMITEDITS is set to True. Edits will actually be made")
else:
    log("SUBMITEDITS is set to False. Edits will not be requested, only simulated")
username,password = dotenv_values()["USER"],dotenv_values()["PASS"]
enwiki = "https://en.wikipedia.org/"
getwithintagsreg = regex.compile('>[^<]+') #Quality
def GetWithinTags(text):
    #Baseplate regex
    return getwithintagsreg.search(text).group()[1:]
InQuotereg = regex.compile('"[^"]*')
def GetInQuote(text):
    #Baseplate regex
    return InQuotereg.search(text).group()[1:]
cookies = {}
def request(method,page,**kwargs):
    global cookies
    request = getattr(requests,method)(page,cookies=cookies,**kwargs)
    if "set-cookie" in request.headers:
        #Handles cookies. Mostly for getting cookies from logging in
        setcookies = request.headers["set-cookie"].split(", ")
        for cookie in setcookies:
            actualCookie = cookie.split(";")[0]
            moreInfo = actualCookie.split("=")
            if moreInfo[0].find(" ") > -1:
                continue
            cookies[moreInfo[0]] = "=".join(moreInfo[1:])
            # print("Set cookie",moreInfo[0],"with value","=".join(moreInfo[1:]))
    return request
def GetTokenForType(actiontype):
    return request("get",enwiki+f"w/api.php?action=query&format=json&meta=tokens&type=*").json()["query"]["tokens"][f"{actiontype}token"]
boundary = "-----------PYB"+str(random.randint(1e9,9e9))
print("Using boundary",boundary)
def CreateFormRequest(location,d):
    #This seems to be the approach that worked consistently for me, so thats what is used for all requests.
    finaltext = ""
    for arg,data in d.items():
        finaltext += f"""{boundary}\nContent-Disposition: form-data; name="{arg}"\n\n{data}\n"""
    finaltext += f"{boundary}--"
    return request("post",location,data=finaltext.encode("utf-8"),headers={"Content-Type":f"multipart/form-data; boundary={boundary[2:]}"})

#NOTE: This section is a mess. Its also vital cause its how any tasks get their information. Do cleanup at some point.
def GetReferenceParameters(reference):
    #Note: Possibly slightly buggy. Be careful and do testing at some point to find out
    result = {}
    starting,ending = reference.find("{{"),reference.find("}}")
    for param in reference[starting+2:ending].split("|"):
        split = param.split("=")
        if not "__TEMPLATE" in result:
            result["__TEMPLATE"] = param.strip()
        else:
            try:
                result[split[0].strip()] = "=".join(split[1:]).strip()
            except:
                continue #Unnammed parameter (Probably a ||)
    return result
wikilinkreg = regex.compile('<a href="/wiki/[^"]+" title="[^"]+">')
WLSpecificreg = regex.compile('"/wiki/[^"]+')
def GetWikiLinks(text):
    #Does what the name suggests. Note that this is looking for GetWikiText, not GetRawWikiText. Consider changing that
    return [WLSpecificreg.search(x).group()[7:] for x in wikilinkreg.findall(text)]
wholepagereg = regex.compile('<div id="bodyContent" class="vector-body">(.*\n)+<div c') #Potentially a bad move? NOTE: See if convenient API exists
def GetWikiText(article):
    return wholepagereg.search(requests.get(enwiki+"wiki/"+article).text).group()[42:-6]
def GetWholeWikiText(article):
    return requests.get(enwiki+"wiki/"+article,cookies=cookies).text #More for debugging, shouldnt really be used
#The repeated [^X] is probably bad, but oh well!
rawtextreg = regex.compile('<textarea [^>]+>[^<]+</textarea>')
def GetRawWikiText(article):
    #Gets the regular text, as seen in Edit source
    content = requests.get(enwiki+"wiki/"+article+"?action=edit",cookies=cookies).text
    rawtext = rawtextreg.search(content).group()
    return regex.sub("&amp;","&",regex.sub("&lt;","<",GetWithinTags(rawtext))) #&lt; and &amp; autocorrection
RefLocator = regex.compile("<ref[^>]*>{{[^}]+}}</ref>") #Note: Only cares about refs using a {{template}}
def GetReferences(text):
    return RefLocator.findall(text)

namespaces = ["User","Wikipedia","WP","File","MediaWiki","Template","Help","Category","Portal","Draft","TimedText","Module"] #Gadget( definition) is deprecated
pseudoNamespaces = {"CAT":"Category","H":"Help","MOS":"Wikipedia","WP":"Wikipedia","WT":"Wikipedia talk",
                    "Project":"Wikipedia","Project_talk":"Wikipedia talk","Image":"File","Image_talk":"File talk",
                    "WikiProject":"Wikipedia","T":"Template","MP":"Article","P":"Portal","MoS":"Wikipedia"} #Special cases that dont match normal sets
def GetNamespace(articlename):
    #Simply gets the namespace of an article from its name
    for namespace in namespaces:
        if articlename.startswith(namespace+":"):
            return namespace
        if articlename.startswith(namespace+"_talk:"):
            return namespace+" talk"
    prefix = articlename.split(":")[0]
    if prefix in pseudoNamespaces:
        return pseudoNamespaces[prefix]
    if articlename.startswith("Talk:"):
        return "Talk"
    if articlename.startswith("Special:"):
        return "Special"
    return "Article"
def IterateCategory(category,torun):
    #Iterates all wikilinks of a category, even if multi-paged
    #Note: If the page scanning is successful, make sure to return True, or else this wont know
    lastpage = ""
    wholepage = GetWikiText(category)
    links = GetWikiLinks(wholepage)
    for page in links:
        if torun(page):
            lastpage = page
    #If we dont get a lastpage in the first place, its either empty, or the task needs configuring. Escape either way
    while lastpage:
        newlastpage = ""
        wholepage = GetWikiText(category+"?from="+lastpage)
        links = GetWikiLinks(wholepage)
        for page in links:
            if torun(page):
                newlastpage = page
        if newlastpage:
            if ord(newlastpage[0]) < ord(lastpage[0]) or newlastpage == lastpage:
                #Determines if we have either looped, or gone back pages due to wikilinks in other sections.
                #Either way, its finished, and we should now exit
                log(f"Looped around, finished scanning {category}")
                break
            lastpage = newlastpage
        else:
            #No pages could be found in the category, its finished. Exit
            log(f"No more LPC, finished scanning {category}")
            break

lastEditTime = 0
editCount = 0
def ChangeWikiPage(article,newcontent,editsummary):
    #Submits edits to pages automatically (since the form is a bit of a nightmare)
    global lastEditTime
    global editCount
    editCount += 1
    if editCount % 10 == 0:
        print("Edit count:",editCount) #Purely statistical
    if not SUBMITEDITS:
        return print(f"Not submitting changes to {article} as SUBMITEDITS is set to False")
    log(f"Making edits to {article}:\n    {editsummary}")
    EPS = 60/maxEditsPerMinute #Incase you dont wanna go too fast
    if time.time()-lastEditTime < EPS:
        print("Waiting for edit cooldown to wear off")
    while time.time()-lastEditTime < EPS:
        time.sleep(.2)
    lastEditTime = time.time()
    return CreateFormRequest(enwiki+f"/w/index.php?title={article}&action=submit",{"wpUnicodeCheck":"ℳ𝒲♥𝓊𝓃𝒾𝒸ℴ𝒹ℯ","wpTextbox1":newcontent,"wpSummary":editsummary,"wpEditToken":GetTokenForType("csrf"),"wpUltimateParam":"1"})
def SubstituteIntoString(wholestr,substitute,start,end):
    return wholestr[:start]+substitute+wholestr[end:]

log(f"Attempting to log-in as {username}")
CreateFormRequest(enwiki+f"w/api.php?action=login&format=json",{"lgname":username,"lgpassword":password,"lgtoken":GetTokenForType("login")}) #Set-Cookie handles this
if not "centralauth_User" in cookies:
    log(f"[!] Failed to log-in as {username}, check the password and username are correct")
    exit()
log("Successfully logged in")

#Task loader
log("Attempting to load tasks...")
execList = {}
#Odd approach but it works
for file in os.listdir("Tasks"):
    if not file.endswith(".py"):
        continue
    if not os.path.isfile("Tasks/"+file):
        continue
    if file[:-3].lower() in EnabledTasks: #Removes .py extension
        execList[file] = bytes("#coding: utf-8\n","utf-8")+open("Tasks/"+file,"rb").read()
    else:
        log(f"[Tasks] Skipping task {file} as it is not enabled")
for file,contents in execList.items():
    try:
        log(f"[Tasks] Running task {file}")
        taskThread = threading.Thread(target=exec,args=(contents,globals()))
        taskThread.start()
    except Exception as exc:
        log(f"[Tasks] Task {file} loading error -> {exc}")
log("Finished loading tasks")
while True:
    time.sleep(120)
    tasks = threading.active_count()
    log(f"Active task count: {tasks-1}")
    if tasks == 1:
        log("All tasks seem to have been terminated or finished. Exiting script in 15 seconds..")
        time.sleep(15)
        break
input("Press enter to exit...")
